#include "/Engine/Private/Common.ush"

uint InteractionTextureResMinus1;
float RenderAreaScalar;
float DeltaTime;
float PostDeltaTimes2;
float TemporalFilterFactor;
float SnowAddition;
float SnowAdditionHeightPrec;
float MaxSnowDepth;
uint TemporalFilterFlag;
float2 SampleOffset;
float2 InteractionCenterWS;
float NonUniformExponent;
float2 ViewToClipDepthFactor;
float4 InvDeviceZToWorldZTransform;

Texture2D PrevDeformation;
Texture2D DepthRT;
SamplerState DepthSampler;
RWTexture2D<float> PersistanceTexture;
RWTexture2D<float4> OutputTexture;

float DeformConvertFromDeviceZ(float DeviceZ)
{
	// Supports ortho and perspective, see CreateInvDeviceZToWorldZTransform()
    return DeviceZ * InvDeviceZToWorldZTransform[0] + InvDeviceZToWorldZTransform[1] + 1.0f / (DeviceZ * InvDeviceZToWorldZTransform[2] - InvDeviceZToWorldZTransform[3]);
}

groupshared float HeightLDS[324];

[numthreads(16, 16, 1)]
void MainCS(uint3 DispatchThreadID : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex, uint3 GroupThreadID : SV_GroupThreadID, uint3 GroupID : SV_GroupID )
{
    int2 SampleOffsetRemap = int2(-SampleOffset.x, SampleOffset.y);
    int2 SharedMemoryLoadPos = (GroupID.xy << 4) - int2(1, 1) + SampleOffsetRemap;
    float TempHeight = PrevDeformation.Load(int3(SharedMemoryLoadPos + int2(GroupIndex % 18, GroupIndex / 18), 0));
    HeightLDS[GroupIndex] = TempHeight;
    uint ExtraIndex = GroupIndex + 256;

    if (ExtraIndex < 324)
    {
        float TempHeight1 = PrevDeformation.Load(int3(SharedMemoryLoadPos + int2(ExtraIndex % 18, ExtraIndex / 18), 0));
        HeightLDS[ExtraIndex] = TempHeight1;
    }

    float ResultHeight = 0.0;
    float2 UV01 = (DispatchThreadID.xy - float2(0.5, 0.5)) / float2(InteractionTextureResMinus1, InteractionTextureResMinus1);
    float2 RenderAreaMinMax = float2(0.5 - RenderAreaScalar * 0.5, RenderAreaScalar * 0.5 + 0.5);
  
    GroupMemoryBarrierWithGroupSync();
  
    uint SharedMemoryStartPos = GroupThreadID.y * 18;
    float Center = HeightLDS[GroupThreadID.x + 19 + SharedMemoryStartPos];
    float Top = HeightLDS[GroupThreadID.x + 1 + SharedMemoryStartPos];
    float Right = HeightLDS[GroupThreadID.x + 20 + SharedMemoryStartPos];
    float Down = HeightLDS[GroupThreadID.x + 37 + SharedMemoryStartPos];
    float Left = HeightLDS[GroupThreadID.x + 18 + SharedMemoryStartPos];
    float TopRight = HeightLDS[GroupThreadID.x + 2 + SharedMemoryStartPos];
    float DownRight = HeightLDS[GroupThreadID.x + 38 + SharedMemoryStartPos];
    float TopLeft = HeightLDS[GroupThreadID.x + SharedMemoryStartPos];
    float DownLeft = HeightLDS[GroupThreadID.x + 36 + SharedMemoryStartPos];
    float Average = saturate((Center + Top + Right + Down + Left + TopRight + DownRight + TopLeft + DownLeft) / 9);
  
    float3 Normal = normalize(float3((Left - Right) * MaxSnowDepth, (Top - Down) * MaxSnowDepth, PostDeltaTimes2));
    float TemporalFilter = saturate(DeltaTime * 30 * (1.0 - saturate(Normal.z * TemporalFilterFactor)));
    float TemporalFilterHeight = (Average - Center) * TemporalFilterFlag * TemporalFilter + Center;
    
    bool bInArea = (DispatchThreadID.xy + SampleOffsetRemap) <= InteractionTextureResMinus1 && 0 <= (DispatchThreadID + SampleOffsetRemap) && RenderAreaMinMax.xx <= UV01 && UV01 <= RenderAreaMinMax.yy;
    if (bInArea)
    {
            ResultHeight = max(TemporalFilterHeight, Center);
        
            float2 ScaledUV01 = (UV01 - RenderAreaMinMax.xx) / RenderAreaScalar;
            float2 NDC = pow(abs(ScaledUV01 * 2.0 - 1.0), NonUniformExponent);
            float2 WarpNDC = (ScaledUV01 * 2.0 - 1.0) * NDC;
            WarpNDC = WarpNDC * 0.5 + 0.5;
            float Depth = Texture2DSampleLevel(DepthRT, DepthSampler, WarpNDC, 0).x;
            if (Depth < 65504.0f)
            {
                float SceneHeight = Texture2DSampleLevel(DepthRT, DepthSampler, WarpNDC, 0).y;
                float InteractionObjectHeight = Depth;
                if (InteractionObjectHeight < (SceneHeight + MaxSnowDepth))
                    ResultHeight = max(1.0 - saturate((InteractionObjectHeight - SceneHeight) / MaxSnowDepth), ResultHeight);
            }
    }

    float2 BorderModulateFactorUV = saturate((1.0 - abs(UV01 * 2.0 - 1.0)) * 10);
    float BorderModulateFactor = min(BorderModulateFactorUV.x, BorderModulateFactorUV.y);   //270
    float RemapZ = (Normal.z - 1.0) * BorderModulateFactor + 1.0; //275
    float3 RemapNormal = float3(Normal.x, Normal.y, RemapZ);
    float ReverseRemapNormalLength = 1.0 / length(RemapNormal); // 277
    float RemapNormalFactor = 1.0 / sqrt(8.0 * ReverseRemapNormalLength * RemapZ + 8.0);

    float2 NormalXY = float2(RemapNormal.xy * BorderModulateFactor * ReverseRemapNormalLength * RemapNormalFactor) + 0.5;
    float FilterHeight = BorderModulateFactor * saturate(max(Average, Center) - SnowAdditionHeightPrec);
    
    PersistanceTexture[DispatchThreadID.xy] = saturate(ResultHeight - SnowAddition);
    OutputTexture[DispatchThreadID.xy] = float4(NormalXY, FilterHeight, 1.0);
}